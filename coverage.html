
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>load-balancing: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/handcoding-labs/redis-stream-client-go/examples/load-balancing/main.go (0.0%)</option>
				
				<option value="file1">github.com/handcoding-labs/redis-stream-client-go/impl/helpers.go (0.0%)</option>
				
				<option value="file2">github.com/handcoding-labs/redis-stream-client-go/impl/init.go (0.0%)</option>
				
				<option value="file3">github.com/handcoding-labs/redis-stream-client-go/impl/opts.go (0.0%)</option>
				
				<option value="file4">github.com/handcoding-labs/redis-stream-client-go/impl/relredis.go (0.0%)</option>
				
				<option value="file5">github.com/handcoding-labs/redis-stream-client-go/notifs/broker.go (0.0%)</option>
				
				<option value="file6">github.com/handcoding-labs/redis-stream-client-go/notifs/lbsmsg.go (0.0%)</option>
				
				<option value="file7">github.com/handcoding-labs/redis-stream-client-go/notifs/relredisnotif.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/redis/go-redis/v9"

        "github.com/handcoding-labs/redis-stream-client-go/impl"
        "github.com/handcoding-labs/redis-stream-client-go/notifs"
        "github.com/handcoding-labs/redis-stream-client-go/types"
)

func main() <span class="cov0" title="0">{
        // Check if this is running as a producer
        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == "producer" </span><span class="cov0" title="0">{
                runProducer()
                return
        }</span>

        // Run as consumer
        <span class="cov0" title="0">runConsumer()</span>
}

func runConsumer() <span class="cov0" title="0">{
        // Set up context with cancellation
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle graceful shutdown
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        // Get consumer ID from environment
        consumerID := os.Getenv("POD_NAME")
        if consumerID == "" </span><span class="cov0" title="0">{
                consumerID = fmt.Sprintf("consumer-%d", time.Now().Unix())
                os.Setenv("POD_NAME", consumerID)
        }</span>

        <span class="cov0" title="0">slog.Info("Starting consumer", "consumer_id", consumerID)

        // Create Redis client
        // Use environment variable for Redis address, default to localhost for local development
        redisAddr := os.Getenv("REDIS_ADDR")
        if redisAddr == "" </span><span class="cov0" title="0">{
                redisAddr = "localhost:6379"
        }</span>

        <span class="cov0" title="0">redisClient := redis.NewUniversalClient(&amp;redis.UniversalOptions{
                Addrs: []string{redisAddr},
                DB:    0,
        })
        defer redisClient.Close()

        // Test Redis connection
        if err := redisClient.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to connect to Redis", "error", err)
                os.Exit(1)
        }</span>

        // Enable keyspace notifications
        <span class="cov0" title="0">if err := redisClient.ConfigSet(ctx, "notify-keyspace-events", "Ex").Err(); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to enable keyspace notifications", "error", err)
                os.Exit(1)
        }</span>

        // Create Redis Stream Client
        <span class="cov0" title="0">client, err := impl.NewRedisStreamClient(redisClient, "load-balance-demo")
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("could not initialize", "error", err.Error())
        }</span>
        <span class="cov0" title="0">slog.Info("Created client", "client_id", client.ID())

        // Initialize the client
        outputChan, err := client.Init(ctx)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to initialize client", "error", err)
                os.Exit(1)
        }</span>

        // Track processed streams
        <span class="cov0" title="0">var processedStreams sync.Map
        var streamCount int32

        // Process notifications
        // The internal NotificationBroker ensures thread-safe delivery from multiple sources:
        // - LBS stream reader
        // - Keyspace notification listener
        // - Key extenders (one per active stream)
        go func() </span><span class="cov0" title="0">{
                for notification := range outputChan </span><span class="cov0" title="0">{
                        switch notification.Type </span>{
                        case notifs.StreamAdded:<span class="cov0" title="0">
                                slog.Info("üéâ New stream assigned", "consumer_id", consumerID)
                                go handleStreamAdded(ctx, client, notification, &amp;processedStreams, &amp;streamCount)</span>

                        case notifs.StreamExpired:<span class="cov0" title="0">
                                slog.Warn("‚ö†Ô∏è  Stream expired, attempting to claim", "consumer_id", consumerID, "payload", notification.Payload)
                                if err := client.Claim(ctx, notification.Payload); err != nil </span><span class="cov0" title="0">{
                                        slog.Error("‚ùå Failed to claim expired stream", "consumer_id", consumerID, "error", err)
                                }</span> else<span class="cov0" title="0"> {
                                        slog.Info("‚úÖ Successfully claimed expired stream", "consumer_id", consumerID)
                                        go handleClaimedStream(ctx, client, notification.Payload.DataStreamName, &amp;processedStreams, &amp;streamCount)
                                }</span>

                        case notifs.StreamDisowned:<span class="cov0" title="0">
                                slog.Warn("‚ùå Stream disowned", "consumer_id", consumerID, "payload", notification.Payload)</span>

                        case notifs.StreamTerminated:<span class="cov0" title="0">
                                // This notification indicates the channel is closing
                                // The reason is available in AdditionalInfo
                                reason := "unknown"
                                if info, ok := notification.AdditionalInfo["info"].(string); ok </span><span class="cov0" title="0">{
                                        reason = info
                                }</span>
                                <span class="cov0" title="0">slog.Info("üì¥ Notification channel terminating", "consumer_id", consumerID, "reason", reason)</span>
                        }
                }
                <span class="cov0" title="0">slog.Info("Notification channel closed", "consumer_id", consumerID)</span>
        }()

        // Print statistics periodically
        <span class="cov0" title="0">go printStatistics(ctx, consumerID, &amp;processedStreams, &amp;streamCount)

        // Wait for shutdown signal
        &lt;-sigChan
        slog.Info("üõë Shutdown signal received, cleaning up...", "consumer_id", consumerID)

        // Graceful shutdown
        // Done() ensures all pending notifications are drained via the NotificationBroker
        // before the output channel is closed
        if err := client.Done(ctx); err != nil </span><span class="cov0" title="0">{
                slog.Error("‚ùå Error during cleanup", "consumer_id", consumerID, "error", err)
        }</span> else<span class="cov0" title="0"> {
                slog.Info("‚úÖ Client cleanup completed", "consumer_id", consumerID)
        }</span>
}

func runProducer() <span class="cov0" title="0">{
        ctx := context.Background()

        slog.Info("üè≠ Starting producer...")

        // Create Redis client
        // Use environment variable for Redis address, default to localhost for local development
        redisAddr := os.Getenv("REDIS_ADDR")
        if redisAddr == "" </span><span class="cov0" title="0">{
                redisAddr = "localhost:6379"
        }</span>

        <span class="cov0" title="0">redisClient := redis.NewUniversalClient(&amp;redis.UniversalOptions{
                Addrs: []string{redisAddr},
                DB:    0,
        })
        defer redisClient.Close()

        // Test connection
        if err := redisClient.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to connect to Redis", "error", err)
                os.Exit(1)
        }</span>

        // Produce messages continuously
        <span class="cov0" title="0">messageID := 0
        for </span><span class="cov0" title="0">{
                // Create batch of messages
                for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                        lbsMessage := notifs.LBSInputMessage{
                                DataStreamName: fmt.Sprintf("order-stream-%d", messageID),
                                Info: map[string]interface{}{
                                        "order_id":    fmt.Sprintf("order-%d", messageID),
                                        "customer_id": fmt.Sprintf("customer-%d", messageID%100),
                                        "amount":      float64(messageID%1000 + 100),
                                        "created_at":  time.Now().Format(time.RFC3339),
                                        "status":      "pending",
                                        "priority":    []string{"low", "normal", "high"}[messageID%3],
                                },
                        }

                        messageData, err := json.Marshal(lbsMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("‚ùå Failed to marshal message", "error", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">result := redisClient.XAdd(ctx, &amp;redis.XAddArgs{
                                Stream: "load-balance-demo-input",
                                Values: map[string]interface{}{
                                        "lbs-input": string(messageData),
                                },
                        })

                        if result.Err() != nil </span><span class="cov0" title="0">{
                                slog.Error("‚ùå Failed to add message", "error", result.Err())
                        }</span> else<span class="cov0" title="0"> {
                                slog.Info("üì§ Produced message", "message_id", messageID, "stream_name", lbsMessage.DataStreamName)
                        }</span>

                        <span class="cov0" title="0">messageID++</span>
                }

                // Wait before next batch
                <span class="cov0" title="0">time.Sleep(3 * time.Second)</span>
        }
}

func handleStreamAdded(ctx context.Context, client types.RedisStreamClient, notification notifs.RecoverableRedisNotification, processedStreams *sync.Map, streamCount *int32) <span class="cov0" title="0">{
        consumerID := client.ID()
        streamName := notification.Payload.DataStreamName

        slog.Info("üîÑ Processing stream", "consumer_id", consumerID, "stream_name", streamName)
        slog.Debug("üìã Stream details", "consumer_id", consumerID, "stream_info", notification.Payload)

        // Simulate processing time (varies by priority)
        processingTime := 2 * time.Second
        if priority, ok := notification.AdditionalInfo["priority"].(string); ok </span><span class="cov0" title="0">{
                switch priority </span>{
                case "high":<span class="cov0" title="0">
                        processingTime = 1 * time.Second</span>
                case "low":<span class="cov0" title="0">
                        processingTime = 4 * time.Second</span>
                }
        }

        // Simulate work
        <span class="cov0" title="0">time.Sleep(processingTime)

        // Mark as processed
        processedStreams.Store(streamName, time.Now())
        *streamCount++

        // Mark stream as done after processing
        if err := client.DoneStream(ctx, streamName); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to mark stream done", "error", err, "stream", streamName, "consumer_id", consumerID)
        }</span> else<span class="cov0" title="0"> {
                slog.Info("‚úÖ Completed processing stream", "consumer_id", consumerID, "stream_name", streamName, "processing_time", processingTime)
        }</span>
}

func handleClaimedStream(ctx context.Context, client types.RedisStreamClient, streamName string, processedStreams *sync.Map, streamCount *int32) <span class="cov0" title="0">{
        slog.Info("üîÑ Processing claimed stream", "consumer_id", client.ID(), "stream_name", streamName)

        // Simulate processing the claimed stream
        time.Sleep(1 * time.Second)

        processedStreams.Store(streamName, time.Now())
        *streamCount++

        // Mark stream as done after processing
        if err := client.DoneStream(ctx, streamName); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to mark claimed stream done", "error", err, "stream", streamName, "consumer_id", client.ID())
        }</span> else<span class="cov0" title="0"> {
                slog.Info("‚úÖ Completed processing claimed stream", "consumer_id", client.ID(), "stream_name", streamName)
        }</span>
}

func printStatistics(ctx context.Context, consumerID string, processedStreams *sync.Map, streamCount *int32) <span class="cov0" title="0">{
        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        count := *streamCount
                        slog.Info("üìä Statistics", "consumer_id", consumerID, "processed_streams", count)

                        // Show recent streams
                        recentCount := 0
                        processedStreams.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                                if processedTime, ok := value.(time.Time); ok </span><span class="cov0" title="0">{
                                        if time.Since(processedTime) &lt; 10*time.Second </span><span class="cov0" title="0">{
                                                recentCount++
                                        }</span>
                                }
                                <span class="cov0" title="0">return true</span>
                        })

                        <span class="cov0" title="0">if recentCount &gt; 0 </span><span class="cov0" title="0">{
                                slog.Info("üìà Recent activity", "consumer_id", consumerID, "recent_streams", recentCount)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package impl

import (
        "context"
        "log/slog"
        "os"

        "github.com/handcoding-labs/redis-stream-client-go/configs"
)

func (r *RecoverableRedisStreamClient) lbsGroupName() string <span class="cov0" title="0">{
        return r.serviceName + configs.GroupSuffix
}</span>

func (r *RecoverableRedisStreamClient) lbsName() string <span class="cov0" title="0">{
        return r.serviceName + configs.InputSuffix
}</span>

func (r *RecoverableRedisStreamClient) isContextDone(ctx context.Context) bool <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (r *RecoverableRedisStreamClient) isStreamProcessingDone(dataStreamName string) bool <span class="cov0" title="0">{
        r.streamLocksMutex.Lock()
        defer r.streamLocksMutex.Unlock()
        return r.streamLocks[dataStreamName] == nil
}</span>

func (r *RecoverableRedisStreamClient) closeOutputChan() <span class="cov0" title="0">{
        r.notificationBroker.Close() // stop accepting new sends
        r.notificationBroker.Wait()  // let run drain the messages from input
        close(r.outputChan)          // close output channel
}</span>

// getGoogleCloudLogger returns a slog.Logger that writes to stdout.
// This logger is compatible with Google Cloud Logging; see
// https://cloud.google.com/logging/docs/structured-logging for more
// details on structured logging that Cloud Logging expects.
func getGoogleCloudLogger() *slog.Logger <span class="cov0" title="0">{
        return slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr </span><span class="cov0" title="0">{
                        switch a.Key </span>{
                        case slog.LevelKey:<span class="cov0" title="0">
                                a.Key = "severity"
                                if level, ok := a.Value.Any().(slog.Level); ok </span><span class="cov0" title="0">{
                                        switch level </span>{
                                        case slog.LevelDebug:<span class="cov0" title="0">
                                                a.Value = slog.StringValue("DEBUG")</span>
                                        case slog.LevelInfo:<span class="cov0" title="0">
                                                a.Value = slog.StringValue("INFO")</span>
                                        case slog.LevelWarn:<span class="cov0" title="0">
                                                a.Value = slog.StringValue("WARNING")</span>
                                        case slog.LevelError:<span class="cov0" title="0">
                                                a.Value = slog.StringValue("ERROR")</span>
                                        default:<span class="cov0" title="0">
                                                a.Value = slog.StringValue("DEFAULT")</span>
                                        }
                                }
                        case slog.TimeKey:<span class="cov0" title="0">
                                a.Key = "timestamp"</span>
                        case slog.MessageKey:<span class="cov0" title="0">
                                a.Key = "message"</span>
                        }
                        <span class="cov0" title="0">return a</span>
                },
                Level: slog.LevelDebug,
        }))
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package impl

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "time"

        "github.com/handcoding-labs/redis-stream-client-go/configs"
        "github.com/handcoding-labs/redis-stream-client-go/notifs"

        "github.com/go-redsync/redsync/v4"
        "github.com/redis/go-redis/v9"
)

func (r *RecoverableRedisStreamClient) enableKeyspaceNotifsForExpiredEvents(ctx context.Context) error <span class="cov0" title="0">{
        // subscribe to key space events for expiration only
        // https://redis.io/docs/latest/develop/use/keyspace-notifications/
        existingConfig := r.redisClient.ConfigGet(ctx, configs.NotifyKeyspaceEventsCmd)
        configVals, err := existingConfig.Result()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, v := range configVals </span><span class="cov0" title="0">{
                if len(v) &gt; 0 </span><span class="cov0" title="0">{
                        // some config for key space notifications already exists, so exit
                        if !r.forceOverrideConfig </span><span class="cov0" title="0">{
                                return fmt.Errorf("detected existing configuration for key space notifications and force override is disabled")
                        }</span> else<span class="cov0" title="0"> {
                                slog.Warn("overriding existing keyspace notifications config since force override is set")
                        }</span>
                }
        }

        <span class="cov0" title="0">res := r.redisClient.ConfigSet(ctx, configs.NotifyKeyspaceEventsCmd, configs.KeyspacePatternForExpiredEvents)
        if res.Err() != nil </span><span class="cov0" title="0">{
                return res.Err()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *RecoverableRedisStreamClient) subscribeToExpiredEvents(ctx context.Context) error <span class="cov0" title="0">{
        r.pubSub = r.redisClient.PSubscribe(ctx, configs.ExpiredEventPattern)
        r.kspChan = r.pubSub.Channel(
                redis.WithChannelHealthCheckInterval(5*time.Second),
                redis.WithChannelSendTimeout(r.kspChanTimeout),
                redis.WithChannelSize(r.kspChanSize),
        )
        return nil
}</span>

// This method doesn't return error and just logs because we execute this
// when no consumer was around to recevie notifications and messages were pending.
// So, this method is just recovering those messages and if there is an issue in
// processing them, then erroring out will stop consumer from processing latest streams also.
func (r *RecoverableRedisStreamClient) recoverUnackedLBS(ctx context.Context) <span class="cov0" title="0">{
        // nextStart is initialized to empty string to claiming can start
        // when it gets populated as 0-0 as a result to auto claim,
        // it means there is nothing more to claim or process
        nextStart := ""
        var unackedMessages []redis.XMessage
        for nextStart != configs.StartIDPair </span><span class="cov0" title="0">{
                xautoClaimRes := r.redisClient.XAutoClaim(ctx, &amp;redis.XAutoClaimArgs{
                        Stream:   r.lbsName(),
                        Group:    r.lbsGroupName(),
                        MinIdle:  r.lbsIdleTime,
                        Start:    configs.StartIDPair,
                        Count:    int64(r.lbsRecoveryCount),
                        Consumer: r.consumerID,
                })

                if xautoClaimRes.Err() != nil </span><span class="cov0" title="0">{
                        r.logger.Error("error while getting unacked messages", "error", xautoClaimRes.Err())
                }</span>

                <span class="cov0" title="0">msgs, start := xautoClaimRes.Val()
                unackedMessages = append(unackedMessages, msgs...)
                nextStart = start</span>
        }

        <span class="cov0" title="0">if len(unackedMessages) &gt; 0 </span><span class="cov0" title="0">{
                r.logger.Info("unacked messages found in LBS for consumer", "pending_count", len(unackedMessages))
        }</span> else<span class="cov0" title="0"> {
                r.logger.Info("no unacked messages found in LBS for consumer")
        }</span>

        <span class="cov0" title="0">streams := []redis.XStream{
                {
                        Stream:   r.lbsName(),
                        Messages: unackedMessages,
                },
        }

        // process the message
        if err := r.processLBSMessages(ctx, streams, r.rs); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("fatal error while processing unacked messages", "error", err)
                return
        }</span>
}

func (r *RecoverableRedisStreamClient) readLBSStream(ctx context.Context) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                // check if context is done
                if r.isContextDone(ctx) </span><span class="cov0" title="0">{
                        r.notificationBroker.Send(ctx, notifs.MakeStreamTerminatedNotif("context done"))
                        return
                }</span>

                // blocking read on LBS stream
                <span class="cov0" title="0">res := r.redisClient.XReadGroup(ctx, &amp;redis.XReadGroupArgs{
                        Group:    r.lbsGroupName(),
                        Consumer: r.consumerID,
                        Streams:  []string{r.lbsName(), configs.PendingMsgID},
                        Block:    0,
                })

                if res.Err() != nil </span><span class="cov0" title="0">{
                        if errors.Is(res.Err(), context.Canceled) </span><span class="cov0" title="0">{
                                r.notificationBroker.Send(ctx, notifs.MakeStreamTerminatedNotif(context.Canceled.Error()))
                                return
                        }</span>
                        <span class="cov0" title="0">r.logger.Error("error while reading from LBS", "error", res.Err())

                        r.notificationBroker.Send(ctx, notifs.MakeStreamTerminatedNotif(res.Err().Error()))
                        return</span>
                }

                <span class="cov0" title="0">if err := r.processLBSMessages(ctx, res.Val(), r.rs); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("fatal error while reading lbs", "error", err)
                        r.notificationBroker.Send(ctx, notifs.MakeStreamTerminatedNotif(err.Error()))
                        return
                }</span>
        }
}

func (r *RecoverableRedisStreamClient) processLBSMessages(
        ctx context.Context,
        streams []redis.XStream,
        rs *redsync.Redsync,
) error <span class="cov0" title="0">{
        for _, stream := range streams </span><span class="cov0" title="0">{
                for _, message := range stream.Messages </span><span class="cov0" title="0">{
                        // has to be an LBS message
                        v, ok := message.Values[configs.LBSInput]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("message on LBS stream must be keyed with %s", configs.LBSInput)
                        }</span>

                        // unmarshal the message
                        <span class="cov0" title="0">var lbsMessage notifs.LBSInputMessage
                        val, ok := v.(string)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("error while converting lbs message")
                        }</span>

                        <span class="cov0" title="0">if err := json.Unmarshal([]byte(val), &amp;lbsMessage); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error while unmarshalling LBS message: %w", err)
                        }</span>

                        <span class="cov0" title="0">if lbsMessage.DataStreamName == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("no data stream specified in LBS message")
                        }</span>

                        <span class="cov0" title="0">lbsInfo, err := notifs.CreateByParts(lbsMessage.DataStreamName, message.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // create mutex
                        <span class="cov0" title="0">mutex := rs.NewMutex(lbsInfo.FormMutexKey(),
                                redsync.WithExpiry(r.hbInterval),
                                redsync.WithFailFast(true),
                                redsync.WithRetryDelay(10*time.Millisecond),
                                redsync.WithSetNXOnExtend(),
                                redsync.WithGenValueFunc(func() (string, error) </span><span class="cov0" title="0">{
                                        return r.consumerID, nil
                                }</span>))

                        // lock only once
                        <span class="cov0" title="0">if err := mutex.Lock(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">r.streamLocksMutex.Lock()
                        r.streamLocks[lbsInfo.DataStreamName] = &amp;StreamLocksInfo{
                                LBSInfo:        lbsInfo,
                                Mutex:          mutex,
                                AdditionalInfo: lbsMessage.Info,
                        }
                        r.streamLocksMutex.Unlock()

                        r.notificationBroker.Send(ctx, notifs.Make(notifs.StreamAdded, lbsInfo, lbsMessage.Info))

                        // now, keep extending the lock in a separate go routine
                        go func() </span><span class="cov0" title="0">{
                                if err := r.startExtendingKey(ctx, mutex, lbsInfo, lbsMessage.Info); err != nil </span><span class="cov0" title="0">{
                                        r.logger.Error("Error extending key", "error", err, "stream", lbsInfo.DataStreamName)
                                }</span>
                        }()
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *RecoverableRedisStreamClient) startExtendingKey(
        ctx context.Context,
        mutex *redsync.Mutex,
        lbsInfo notifs.LBSInfo,
        additionalInfo map[string]any,
) error <span class="cov0" title="0">{
        extensionFailed := false
        defer func() </span><span class="cov0" title="0">{
                if extensionFailed </span><span class="cov0" title="0">{
                        // if client is still interested or is coming back from a delay (GC pause etc) then inform about disowning of stream
                        r.notificationBroker.Send(ctx, notifs.Make(notifs.StreamDisowned, lbsInfo, additionalInfo))
                }</span>
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                // exit extending the key if:
                // main context is canceled
                if r.isContextDone(ctx) </span><span class="cov0" title="0">{
                        r.logger.Debug("context done, exiting", "consumer_id", r.consumerID)
                        return nil
                }</span>

                // or if DoneStream was called
                <span class="cov0" title="0">if r.isStreamProcessingDone(lbsInfo.DataStreamName) </span><span class="cov0" title="0">{
                        r.logger.Debug("DoneStream called. Stopping key extension.")
                        return nil
                }</span>

                <span class="cov0" title="0">if ok, err := mutex.Extend(); !ok || err != nil </span><span class="cov0" title="0">{
                        extensionFailed = true
                        return fmt.Errorf("could not extend mutex, err: %s", err)
                }</span>

                <span class="cov0" title="0">time.Sleep(r.hbInterval / 2)</span>
        }
}

func (r *RecoverableRedisStreamClient) listenKsp(ctx context.Context) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        r.logger.Debug("context done, exiting", "consumer_id", r.consumerID)
                        r.notificationBroker.Send(ctx, notifs.MakeStreamTerminatedNotif("context done"))
                        return</span>
                case kspNotif := &lt;-r.kspChan:<span class="cov0" title="0">
                        if kspNotif != nil </span><span class="cov0" title="0">{
                                r.logger.Debug("ksp notif received", "consumer_id", r.consumerID, "payload", kspNotif.Payload)
                                lbsInfo, err := notifs.CreateByKspNotification(kspNotif.Payload)
                                if err != nil </span><span class="cov0" title="0">{
                                        r.logger.Warn("error parsing ksp notification", "ksp_notification", kspNotif)
                                        continue</span>
                                }

                                // Try to get additional info from stored stream locks
                                <span class="cov0" title="0">var additionalInfo map[string]any
                                r.streamLocksMutex.RLock()
                                if streamLockInfo, exists := r.streamLocks[lbsInfo.DataStreamName]; exists </span><span class="cov0" title="0">{
                                        additionalInfo = streamLockInfo.AdditionalInfo
                                }</span>
                                <span class="cov0" title="0">r.streamLocksMutex.RUnlock()

                                r.notificationBroker.Send(ctx, notifs.Make(notifs.StreamExpired, lbsInfo, additionalInfo))</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package impl

import (
        "fmt"
        "time"

        "github.com/handcoding-labs/redis-stream-client-go/notifs"
)

type RecoverableRedisOption func(*RecoverableRedisStreamClient) error

// WithLBSIdleTime sets the time after which a message is considered idle and will be recovered
func WithLBSIdleTime(idleTime time.Duration) RecoverableRedisOption <span class="cov0" title="0">{
        return func(r *RecoverableRedisStreamClient) error </span><span class="cov0" title="0">{
                // idleTime must be greater than 2 * heartbeat interval at least
                if idleTime == 0 || idleTime &lt; (2*r.hbInterval) </span><span class="cov0" title="0">{
                        return fmt.Errorf("idleTime must be greater than 2 * heartbeat interval at least")
                }</span>

                <span class="cov0" title="0">r.lbsIdleTime = idleTime
                return nil</span>
        }
}

// WithLBSRecoveryCount sets the number of messages to fetch at a time during recovery
func WithLBSRecoveryCount(count int) RecoverableRedisOption <span class="cov0" title="0">{
        return func(r *RecoverableRedisStreamClient) error </span><span class="cov0" title="0">{
                if count &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("recovery count must be greater than 0")
                }</span>

                <span class="cov0" title="0">r.lbsRecoveryCount = count
                return nil</span>
        }
}

// WithKspChanSize sets the size of the ksp channel which corresponds to number of
// pub sub notifications that we can receive from redis
func WithKspChanSize(size int) RecoverableRedisOption <span class="cov0" title="0">{
        return func(r *RecoverableRedisStreamClient) error </span><span class="cov0" title="0">{
                if size &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("kspChanSize must be a positive number")
                }</span>

                <span class="cov0" title="0">r.kspChanSize = size
                return nil</span>
        }
}

// WithKspChanTimeout is the duration after which an outstanding pub sub message
// from redis pub sub is dropped from channel
func WithKspChanTimeout(timeout time.Duration) RecoverableRedisOption <span class="cov0" title="0">{
        return func(r *RecoverableRedisStreamClient) error </span><span class="cov0" title="0">{
                if timeout == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("timeout cannot be zero value")
                }</span>

                <span class="cov0" title="0">r.kspChanTimeout = timeout
                return nil</span>
        }
}

// WithForceConfigOverride when set overrides the redis configuration for
// key space notifications
func WithForceConfigOverride() RecoverableRedisOption <span class="cov0" title="0">{
        return func(r *RecoverableRedisStreamClient) error </span><span class="cov0" title="0">{
                r.forceOverrideConfig = true
                return nil
        }</span>
}

// WithOutputChanSize lets the clients set the outputChanSize where different
// notifications are sent
func WithOutputChanSize(size int) RecoverableRedisOption <span class="cov0" title="0">{
        return func(r *RecoverableRedisStreamClient) error </span><span class="cov0" title="0">{
                if size &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("outputChan size must be a positive number")
                }</span>

                <span class="cov0" title="0">r.outputChan = make(chan notifs.RecoverableRedisNotification, size)
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package impl

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/go-redsync/redsync/v4"
        "github.com/go-redsync/redsync/v4/redis/goredis/v9"
        "github.com/redis/go-redis/v9"

        "github.com/handcoding-labs/redis-stream-client-go/configs"
        "github.com/handcoding-labs/redis-stream-client-go/notifs"
        "github.com/handcoding-labs/redis-stream-client-go/types"
)

// StreamLocksInfo holds information needed to operation with data streams and their management for synchronization
type StreamLocksInfo struct {
        LBSInfo        notifs.LBSInfo
        Mutex          *redsync.Mutex
        AdditionalInfo map[string]any
}

// RecoverableRedisStreamClient is an implementation of the RedisStreamClient interface
type RecoverableRedisStreamClient struct {
        // underlying redis client used to interact with redis
        redisClient redis.UniversalClient
        // consumerID is the unique identifier for the consumer
        consumerID string
        // kspChan is the channel to read keyspace notifications
        kspChan &lt;-chan *redis.Message
        // lbsCtxCancelFunc is used to control when to kill go routines spawned as part of lbs
        lbsCtxCancelFunc context.CancelFunc
        // hbInterval is the interval at which the client sends heartbeats
        hbInterval time.Duration
        // streamLocks is a map of stream name to LBSInfo for locking
        streamLocks map[string]*StreamLocksInfo
        // streamLocksMutex protects streamLocks map from concurrent access
        streamLocksMutex sync.RWMutex
        // serviceName is the name of the service
        serviceName string
        // redis pub sub subscription
        pubSub *redis.PubSub
        // outputChan is the channel exposed to clients on which we relay all messages
        outputChan chan notifs.RecoverableRedisNotification
        // rs is a shared redsync instance used for distributed locks
        rs *redsync.Redsync
        // lbsIdleTime is the time after which a message is considered idle
        lbsIdleTime time.Duration
        // lbsRecoveryCount is the number of times a message is recovered
        lbsRecoveryCount int
        // kspChanSize is the size of kspChan corresponding to redis pub sub channel size
        kspChanSize int
        // outputChanSize is the size of the outputChan to which clients listen to
        outputChanSize int
        // kspChanTimeout is the duration after which a pub sub message from redis is dropped
        kspChanTimeout time.Duration
        // logger for plain json logging
        logger *slog.Logger
        // forceOverrideConfig indicates if the library should override existing keyspace notifications config
        forceOverrideConfig bool
        // NotificationBroker handles all messaging to clients
        notificationBroker *notifs.NotificationBroker
}

// NewRedisStreamClient creates a new RedisStreamClient
//
// This function creates a new RedisStreamClient with the given redis client and stream name
// Stream is the name of the stream to read from where actual data is transmitted
func NewRedisStreamClient(redisClient redis.UniversalClient, serviceName string,
        opts ...RecoverableRedisOption) (types.RedisStreamClient, error) <span class="cov0" title="0">{
        // obtain consumer name via kubernetes downward api
        podName := os.Getenv(configs.PodName)
        podIP := os.Getenv(configs.PodIP)

        if podName == "" &amp;&amp; podIP == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("podName or podIP not found in env")
        }</span>

        <span class="cov0" title="0">var consumerID string

        if len(podName) &gt; 0 </span><span class="cov0" title="0">{
                consumerID = configs.RedisConsumerPrefix + podName
        }</span> else<span class="cov0" title="0"> {
                consumerID = configs.RedisConsumerPrefix + podIP
        }</span>

        <span class="cov0" title="0">pool := goredis.NewPool(redisClient)
        rs := redsync.New(pool)

        r := &amp;RecoverableRedisStreamClient{
                redisClient:      redisClient,
                consumerID:       consumerID,
                kspChan:          make(chan *redis.Message, 500),
                hbInterval:       configs.DefaultHBInterval,
                streamLocks:      make(map[string]*StreamLocksInfo),
                serviceName:      serviceName,
                outputChan:       make(chan notifs.RecoverableRedisNotification, configs.DefaultOutputChanSize),
                rs:               rs,
                lbsIdleTime:      configs.DefaultLBSIdleTime,
                lbsRecoveryCount: configs.DefaultLBSRecoveryCount,
                kspChanSize:      configs.DefaultKspChanSize,
                kspChanTimeout:   configs.DefaultKspChanTimeout,
                logger:           getGoogleCloudLogger(),
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(r); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("invalid option: %v", err))</span>
                }
        }

        // init the notification broker
        <span class="cov0" title="0">r.notificationBroker = notifs.NewNotificationBroker(r.outputChan, configs.DefaultOutputChanSize)

        return r, nil</span>
}

// ID returns the consumer name that uniquely identifies the consumer
func (r *RecoverableRedisStreamClient) ID() string <span class="cov0" title="0">{
        return r.consumerID
}</span>

// Init initializes the RedisStreamClient
//
// This function initializes the RedisStreamClient by enabling keyspace notifications for expired events,
// subscribing to expired events, and starting a blocking read on the LBS stream
// Returns a channel to read messages from the LBS stream. The client should read from this channel and
// process the messages.
func (r *RecoverableRedisStreamClient) Init(ctx context.Context) (&lt;-chan notifs.RecoverableRedisNotification, error) <span class="cov0" title="0">{
        keyspaceErr := r.enableKeyspaceNotifsForExpiredEvents(ctx)
        if keyspaceErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error while enabling keyspace notifications for expired events: %w", keyspaceErr)
        }</span>

        <span class="cov0" title="0">expiredErr := r.subscribeToExpiredEvents(ctx)
        if expiredErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error while subscribing to expired events: %w", expiredErr)
        }</span>

        <span class="cov0" title="0">newCtx, cancelFunc := context.WithCancel(ctx)
        r.lbsCtxCancelFunc = cancelFunc

        // create group
        res := r.redisClient.XGroupCreateMkStream(ctx, r.lbsName(), r.lbsGroupName(), configs.StartFromNow)
        if res.Err() != nil &amp;&amp; !strings.Contains(res.Err().Error(), "BUSYGROUP") </span><span class="cov0" title="0">{
                return nil, res.Err()
        }</span>

        // recovery of unacked LBS messages
        <span class="cov0" title="0">r.recoverUnackedLBS(newCtx)

        // start blocking read on LBS stream
        go r.readLBSStream(newCtx)

        // listen to ksp chan
        go r.listenKsp(newCtx)

        return r.outputChan, nil</span>
}

// Claim claims pending messages from a stream
func (r *RecoverableRedisStreamClient) Claim(ctx context.Context, lbsInfo notifs.LBSInfo) error <span class="cov0" title="0">{
        r.logger.Info("claiming stream", "consumer_id", r.consumerID, "mutex_key", lbsInfo,
                "timestamp", time.Now().Format(time.RFC3339))

        // Claim the stream
        res := r.redisClient.XClaim(ctx, &amp;redis.XClaimArgs{
                Stream:   r.lbsName(),
                Group:    r.lbsGroupName(),
                Consumer: r.consumerID,
                MinIdle:  r.hbInterval, // one heartbeat interval must have elapsed
                Messages: []string{lbsInfo.IDInLBS},
        })

        if res.Err() != nil </span><span class="cov0" title="0">{
                r.logger.Error("error claiming stream", "error", res.Err(), "consumer_id", r.consumerID)
                return res.Err()
        }</span>

        <span class="cov0" title="0">claimed, err := res.Result()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("error getting claimed stream", "error", err, "consumer_id", r.consumerID,
                        "mutex_key", lbsInfo.FormMutexKey())
                return err
        }</span>

        <span class="cov0" title="0">if len(claimed) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("already claimed")
        }</span>

        <span class="cov0" title="0">mutex := r.rs.NewMutex(lbsInfo.FormMutexKey(),
                redsync.WithExpiry(r.hbInterval),
                redsync.WithFailFast(true),
                redsync.WithRetryDelay(10*time.Millisecond),
                redsync.WithSetNXOnExtend(),
                redsync.WithGenValueFunc(func() (string, error) </span><span class="cov0" title="0">{
                        return r.consumerID, nil
                }</span>))

        // lock once
        <span class="cov0" title="0">if err := mutex.Lock(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Retrieve the original message to get AdditionalInfo
        <span class="cov0" title="0">var additionalInfo map[string]any
        if len(claimed) &gt; 0 </span><span class="cov0" title="0">{
                if lbsInputStr, ok := claimed[0].Values[configs.LBSInput].(string); ok </span><span class="cov0" title="0">{
                        var lbsMessage notifs.LBSInputMessage
                        if err := json.Unmarshal([]byte(lbsInputStr), &amp;lbsMessage); err == nil </span><span class="cov0" title="0">{
                                additionalInfo = lbsMessage.Info
                        }</span>
                }
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := r.startExtendingKey(ctx, mutex, lbsInfo, additionalInfo); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Error extending key", "error", err, "stream", lbsInfo.DataStreamName, "consumer_id", r.consumerID)
                }</span>
        }()

        // populate StreamLocks info
        <span class="cov0" title="0">r.streamLocksMutex.Lock()
        r.streamLocks[lbsInfo.DataStreamName] = &amp;StreamLocksInfo{
                LBSInfo:        lbsInfo,
                Mutex:          mutex,
                AdditionalInfo: additionalInfo,
        }
        r.streamLocksMutex.Unlock()

        return nil</span>
}

// DoneStream marks end of processing for a particular stream
//
// This function is used to mark the end of processing for a particular stream
// It unlocks the stream and acknowledges the message and cleans up internal state
func (r *RecoverableRedisStreamClient) DoneStream(ctx context.Context, dataStreamName string) error <span class="cov0" title="0">{
        r.streamLocksMutex.Lock()
        streamLocksInfo, ok := r.streamLocks[dataStreamName]
        if !ok </span><span class="cov0" title="0">{
                r.streamLocksMutex.Unlock()
                return fmt.Errorf("stream not found")
        }</span>

        // delete volatile key from streamLocks
        <span class="cov0" title="0">delete(r.streamLocks, dataStreamName)
        r.streamLocksMutex.Unlock()

        // unlock the stream
        _, err := streamLocksInfo.Mutex.Unlock()
        if err != nil &amp;&amp; !errors.Is(errors.Unwrap(err), redsync.ErrLockAlreadyExpired) </span><span class="cov0" title="0">{
                return err
        }</span>

        // Acknowledge the message
        <span class="cov0" title="0">res := r.redisClient.XAck(ctx, r.lbsName(), r.lbsGroupName(), streamLocksInfo.LBSInfo.IDInLBS)
        if res.Err() != nil </span><span class="cov0" title="0">{
                return res.Err()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Done marks the end of processing for a client
//
// Note that done is called when the client is shutting down and is not expected to be called again
// It cleans up all the streams handled by the client
// To cleanup a specific stream, use DoneStream
func (r *RecoverableRedisStreamClient) Done(ctx context.Context) error <span class="cov0" title="0">{
        // Get all stream names first to avoid holding lock during DoneStream calls
        r.streamLocksMutex.RLock()
        streamNames := make([]string, 0, len(r.streamLocks))
        for streamName := range r.streamLocks </span><span class="cov0" title="0">{
                streamNames = append(streamNames, streamName)
        }</span>
        <span class="cov0" title="0">r.streamLocksMutex.RUnlock()

        for _, streamName := range streamNames </span><span class="cov0" title="0">{
                if err := r.DoneStream(ctx, streamName); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // release resources
        <span class="cov0" title="0">if err := r.cleanup(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *RecoverableRedisStreamClient) cleanup() error <span class="cov0" title="0">{
        if err := r.pubSub.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // drain kspchan and ignore expired notifications
        // since client has called Done and thus are no longer interested in expired notifications
        <span class="cov0" title="0">for len(r.kspChan) &gt; 0 </span><span class="cov0" title="0">{
                &lt;-r.kspChan
        }</span>

        // close the output channel
        <span class="cov0" title="0">r.closeOutputChan()

        // cancel LBS context
        r.lbsCtxCancelFunc()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package notifs

import (
        "context"
        "errors"
        "sync"
        "sync/atomic"
)

var (
        ErrContextDone   = errors.New("context is done")
        ErrAlreadyClosed = errors.New("output already closed")
)

type NotificationBroker struct {
        input     chan RecoverableRedisNotification
        output    chan&lt;- RecoverableRedisNotification
        wg        *sync.WaitGroup
        closed    atomic.Bool
        closeOnce sync.Once
        quit      chan struct{}
}

func NewNotificationBroker(output chan&lt;- RecoverableRedisNotification, bufferSize int) *NotificationBroker <span class="cov0" title="0">{
        b := &amp;NotificationBroker{
                input:  make(chan RecoverableRedisNotification, bufferSize),
                output: output,
                wg:     &amp;sync.WaitGroup{},
                quit:   make(chan struct{}),
        }

        b.wg.Add(1)
        go b.run()
        return b
}</span>

func (b *NotificationBroker) run() <span class="cov0" title="0">{
        defer b.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-b.quit:<span class="cov0" title="0">
                        // drain
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case m := &lt;-b.input:<span class="cov0" title="0">
                                        b.output &lt;- m</span>
                                default:<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                case m := &lt;-b.input:<span class="cov0" title="0">
                        b.output &lt;- m</span>
                }
        }
}

func (b *NotificationBroker) Send(ctx context.Context, m RecoverableRedisNotification) bool <span class="cov0" title="0">{
        if b.closed.Load() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return false</span>
        case &lt;-b.quit:<span class="cov0" title="0">
                return false</span>
        case b.input &lt;- m:<span class="cov0" title="0">
                return true</span>
        }
}

func (b *NotificationBroker) Close() <span class="cov0" title="0">{
        b.closeOnce.Do(func() </span><span class="cov0" title="0">{
                b.closed.Store(true)
                close(b.quit)
        }</span>)
}

func (b *NotificationBroker) Wait() <span class="cov0" title="0">{
        b.wg.Wait()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package notifs

import (
        "fmt"
        "strings"

        "github.com/handcoding-labs/redis-stream-client-go/configs"
)

// LBSInfo contains information about a data stream in LBS. It's an internal data structure.
type LBSInfo struct {
        DataStreamName string
        IDInLBS        string
}

func (l *LBSInfo) FormMutexKey() string <span class="cov0" title="0">{
        return strings.Join([]string{l.DataStreamName, l.IDInLBS}, configs.MutexKeySep)
}</span>

func CreateByKspNotification(mutexKey string) (LBSInfo, error) <span class="cov0" title="0">{
        parts := strings.Split(mutexKey, configs.MutexKeySep)
        // must be in format: data_stream_name:message_id_in_lbs
        if len(parts) == 1 || len(parts) &gt; 2 </span><span class="cov0" title="0">{
                return LBSInfo{}, fmt.Errorf("invalid mutex key format: %s", mutexKey)
        }</span>

        <span class="cov0" title="0">return LBSInfo{
                DataStreamName: parts[0],
                IDInLBS:        parts[1],
        }, nil</span>
}

func CreateByParts(dataStreamName string, idInLBS string) (LBSInfo, error) <span class="cov0" title="0">{
        if len(dataStreamName) == 0 || len(idInLBS) == 0 </span><span class="cov0" title="0">{
                return LBSInfo{}, fmt.Errorf("no data to create lbsInfo")
        }</span>

        <span class="cov0" title="0">return LBSInfo{
                DataStreamName: dataStreamName,
                IDInLBS:        idInLBS,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package notifs

// Types of notifications sent to client.
type NotificationType int

const (
        StreamAdded NotificationType = iota
        StreamDisowned
        StreamExpired
        StreamTerminated
)

// RecoverableRedisNotification captures the type of notifications sent to client.
// These are captured by NotificationType enum.
type RecoverableRedisNotification struct {
        Type    NotificationType
        Payload LBSInfo
        // AdditionalInfo is an echo from any additional data seeded in LBSInputMessage
        AdditionalInfo map[string]any
}

// LBSMessage is the format in which the message should be written to LBS
type LBSInputMessage struct {
        DataStreamName string
        Info           map[string]interface{}
}

func Make(notifType NotificationType, lbsInfo LBSInfo, additionalInfo map[string]any) RecoverableRedisNotification <span class="cov0" title="0">{
        return RecoverableRedisNotification{
                Type:           notifType,
                Payload:        lbsInfo,
                AdditionalInfo: additionalInfo,
        }
}</span>

func MakeStreamTerminatedNotif(info string) RecoverableRedisNotification <span class="cov0" title="0">{
        return RecoverableRedisNotification{
                Type:    StreamTerminated,
                Payload: LBSInfo{},
                AdditionalInfo: map[string]any{
                        "info": info,
                },
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
